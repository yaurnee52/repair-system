# Полное руководство по проекту "Информационная система 'Ремонт станков'"

## 1. Введение и общая концепция

Данный проект представляет собой настольное (оконное) приложение, разработанное на языке Java с использованием графической библиотеки **JavaFX**. Его основная цель — автоматизировать учёт и управление ремонтами промышленного оборудования для некоторой компании.

Приложение реализует следующие ключевые возможности:
- **Система ролей**: Разделение пользователей на **Клиентов** и **Администраторов** с разными правами доступа.
- **Аутентификация и регистрация**: Пользователи могут создавать учётные записи и входить в систему.
- **Личный кабинет клиента**: Клиент может просматривать свои станки, историю их ремонтов и создавать новые заявки на ремонт.
- **Управление данными**: Администратор (в перспективе) будет иметь полный доступ ко всем данным системы.
- **Работа с базой данных**: Все данные хранятся в системе управления базами данных **MySQL**.

## 2. Архитектура проекта: MVC (Model-View-Controller)

Проект построен на основе классического и очень популярного архитектурного шаблона **MVC**. Этот подход разделяет всю программу на три логические части, что делает код чистым, организованным и лёгким для понимания и доработки.

#### Model (Модель)
- **Что это?** Это "данные" вашего приложения. Простые Java-классы, которые описывают сущности из реального мира (пользователь, станок, ремонт). Они не содержат никакой логики отображения или управления, только поля для хранения информации.
- **Где в проекте?** Весь код моделей находится в пакете `com.repairshop.model`.

#### View (Представление)
- **Что это?** Это то, что пользователь видит на экране: окна, кнопки, текстовые поля, таблицы. Задача `View` — только отображать интерфейс. В них нет никакой логики, они "глупые".
- **Где в проекте?** Весь код представлений находится в пакете `com.repairshop.view`.

#### Controller (Контроллер)
- **Что это?** Это "мозг" приложения. Он выступает посредником между Моделью и Представлением. Контроллер:
  1.  Получает команды от пользователя (например, нажатие на кнопку в `View`).
  2.  Обращается к базе данных (через специальные классы `DAO`), чтобы получить или изменить данные (`Model`).
  3.  Обновляет `View`, чтобы пользователь увидел результат своих действий.
- **Где в проекте?** Весь код контроллеров находится в пакете `com.repairshop.controller`.

## 3. Настройка и запуск

Чтобы запустить проект, выполните следующие шаги:

1.  **Установите и запустите MySQL Server**.
2.  **Создайте базу данных**. Откройте любой клиент для работы с MySQL (например, MySQL Workbench, DBeaver) и выполните SQL-скрипт из файла `src/main/java/com/repairshop/ConectDB/db.sql`. Этот скрипт создаст базу данных `repair_system` и все необходимые таблицы.
3.  **Настройте подключение**. В папке `src/main/resources` (если её нет, создайте) создайте файл `db.properties`. Заполните его вашими данными:
    ```properties
    db.url=jdbc:mysql://localhost:3306/repair_system
    db.user=root
    db.password=ВАШ_ПАРОЛЬ_ОТ_MYSQL
    ```
4.  **Запустите приложение**. Откройте проект в вашей IDE (например, IntelliJ IDEA) и запустите метод `main` в классе `MainApp.java`.

## 4. Детальное описание компонентов проекта

### Главный класс `MainApp.java`
Это точка входа в приложение.

- **`public class MainApp extends Application`**: Наследование от `Application` является обязательным для любого JavaFX-приложения.
- **`start(Stage stage)`**: Этот метод вызывается, когда JavaFX готов к работе.
  - **Что делает?** Он выполняет первоначальную настройку: создаёт главный контроллер `LoginController`, получает у него его визуальную часть (`getView()`) и устанавливает её как содержимое главного окна (`primaryStage`).
- **`setRoot(Parent root, String title)`**: **Ключевой метод для навигации.** Он позволяет из любого места программы полностью сменить содержимое главного окна. Контроллеры используют его для переключения между "экранами" (например, с экрана входа на экран личного кабинета).
- **`main(String[] args)`**: Стандартный метод `main`, который запускает JavaFX-приложение.

### Пакет `model` (Модель)
Простые классы-контейнеры для данных.

- `Client.java`: Хранит информацию о клиенте-компании. (`id`, `companyName`).
- `Machine.java`: Хранит информацию о конкретном станке. Содержит `clientId` и `machineModelId` для связи с другими таблицами.
- `MachineModel.java`: Хранит информацию о *типе* станка (марка, год, страна).
- `Repair.java`: Хранит информацию о факте ремонта.
- `RepairType.java`: Хранит информацию о виде ремонта (цена, длительность).
- `Role.java`: Хранит информацию о роли пользователя (`id`, `roleName`).
- `User.java`: Хранит информацию о пользователе системы (`id`, `username`, `passwordHash`, `roleId`, `clientId`).

### Пакет `ConectDB`
- **`DatabaseConnection.java`**:
  - **`private static DatabaseConnection instance;`**: Статическое поле для хранения единственного экземпляра класса.
  - **`private DatabaseConnection()`**: Приватный конструктор. Это не позволяет создавать новые экземпляры класса извне.
  - **`public static synchronized DatabaseConnection getInstance()`**: **Ключевой метод шаблона Singleton.** При первом вызове он создаёт новый экземпляр `DatabaseConnection` (и, соответственно, новое подключение к БД) и сохраняет его в `instance`. При всех последующих вызовах он просто возвращает уже существующий экземпляр. `synchronized` гарантирует, что даже в многопоточной среде будет создано только одно подключение.
  - **`getConnection()`**: Возвращает готовый к использованию объект `Connection`.
- **`db.sql`**: Скрипт для создания таблиц. Использует внешние ключи (`FOREIGN KEY`) для обеспечения целостности данных (например, нельзя создать станок для несуществующего клиента).

### Пакет `dao` (Data Access Object)
Этот слой инкапсулирует всю логику работы с SQL.

- **Общий принцип**: Каждый DAO-класс получает объект `Connection` от `DatabaseConnection` и хранит его в поле `private final Connection conn`. В методах используется конструкция `try-with-resources` для `PreparedStatement` и `ResultSet`, но **не для `Connection`**, чтобы не закрыть общее соединение.
- **`UserDAO.java`**:
  - `create(User user)`: Выполняет `INSERT INTO Users...`, вставляя нового пользователя.
  - `read(int id)`: Выполняет `SELECT * FROM Users WHERE id = ?`, ищет пользователя по ID.
  - `readByUsername(String username)`: Ищет пользователя по логину.
  - `update(User user)`: Обновляет все поля пользователя в БД.
  - `delete(int id)`: Удаляет пользователя.
- **`MachineModelDAO.java`**:
  - `findOrCreate(String brand, int year, String country)`: Очень полезный метод. Сначала пытается найти модель по параметрам (`SELECT`). Если находит, возвращает её. Если нет, создаёт новую (`INSERT`) и возвращает её. Это защищает от дубликатов в справочнике моделей.
- **Остальные DAO (`ClientDAO`, `MachineDAO` и т.д.)**: Реализуют аналогичные CRUD-операции (Create, Read, Update, Delete) для своих таблиц.

### Пакет `view` (Представление)
Классы, отвечающие за внешний вид.

- **`LoginView.java`**: Содержит все элементы для окон входа и регистрации (`TextField`, `Button`, `Label` и т.д.).
- **`ClientDashboardView.java`**: Основной "каркас" кабинета клиента. Использует `BorderPane` для размещения навигационной панели (`VBox`) справа и основной контентной области (`StackPane`) в центре.
- **Остальные View**: Аналогично создают и компонуют элементы для своих панелей.

### Пакет `controller` (Контроллер)
"Сердце" приложения, где происходит вся логика.

- **`LoginController.java`**:
  - **Назначение**: Управляет логикой входа и регистрации.
  - **`LoginController()` (конструктор)**: Здесь происходит "магия" связывания. Контроллер берёт кнопки из `LoginView` и назначает им обработчики событий (`setOnAction`). В качестве обработчика используется анонимный класс `EventHandler`, внутри которого вызывается нужный метод контроллера.
  - **`handleLogin()`**: Вызывается при нажатии кнопки "Войти". Получает данные из полей `LoginView`, обращается к `UserDAO` для проверки пользователя и, в случае успеха, вызывает `MainApp.setRoot()`, чтобы переключить окно на соответствующий кабинет.
  - **`handleRegister()`**: Аналогично обрабатывает регистрацию.

- **`ClientDashboardController.java`**:
  - **Назначение**: Управляет навигацией в личном кабинете клиента.
  - **`setupActions()`**: Привязывает к кнопкам навигации методы `showMainPanel()`, `showProfilePanel()` и т.д.
  - **`show...()` методы**: Реализуют шаблон переключения панелей:
    1.  Создаётся контроллер нужной панели (например, `MyMachinesPanelController`).
    2.  У этого контроллера забирается его готовое представление (`getView()`).
    3.  Это представление помещается в центральную область `ClientDashboardView`, затирая старое содержимое.

- **`ClientProfilePanelController.java`**:
  - **Назначение**: Управляет панелью профиля.
  - **`loadData()`**: При инициализации загружает данные текущего пользователя и его компании (если она есть) с помощью `UserDAO` и `ClientDAO` и заполняет ими поля в `ClientProfilePanelView`.
  - **`handleSave()`**: При нажатии кнопки "Сохранить" считывает данные из полей, обновляет объекты `User` и `Client` и отправляет их в `UserDAO` и `ClientDAO` для сохранения в базе данных.

- **`MyMachinesPanelController.java`**:
  - **Назначение**: Управляет панелью "Мои станки".
  - **`initialize()`**: **Важный порядок!** Сначала вызывает `setupTables()`, чтобы создать структуру таблиц, и только потом `loadData()`, чтобы заполнить их.
  - **`setupTables()`**: Создаёт колонки для `TableView`. Для простых полей (как `id` у станка) используется `PropertyValueFactory`. Для сложных данных (например, чтобы показать марку станка, зная только ID его модели) используются **внутренние классы-помощники** (`PropertyValueFactoryForMachine`), которые ищут информацию в `Map`-кэше.
  - **`loadData()`**: Загружает из базы данных все станки клиента, а также все модели станков и виды ремонта, чтобы хранить их в `Map` (кэше) для быстрого доступа.
  - **`setupListeners()`**: Добавляет "слушателя" к таблице станков. Когда пользователь выбирает другой станок, вызывается `loadRepairsForMachine()`, чтобы обновить таблицу с историей ремонтов.

- **`RepairRequestPanelController.java`**:
  - **Назначение**: Управляет панелью создания заявки на ремонт.
  - **`handleSubmit()`**:
    1.  Проверяет, выбран ли "новый" или "существующий" станок.
    2.  Для нового станка: проверяет, заполнена ли компания в профиле, считывает данные, вызывает `machineModelDAO.findOrCreate()` и `machineDAO.create()`.
    3.  Для существующего: просто берет выбранный станок из `ComboBox`.
    4.  Проверяет, что вид ремонта и дата выбраны.
    5.  Создаёт объект `Repair` и сохраняет его через `repairDAO.create()`.
    6.  **Ключевой шаг для UX**: Вызывает `loadData()` в конце, чтобы список существующих станков в `ComboBox` сразу же обновился.